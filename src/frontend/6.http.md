
## HTTP 与 TCP/IP

### Q.  什么是HTTP，它的用途是什么？

HTTP（HyperText Transfer Protocol，超文本传输协议）是一种用于在互联网上进行数据通信的应用层协议。它基于 TCP/IP 协议栈工作，通常使用 TCP 作为传输层协议。HTTP 的主要作用是规定了客户端（例如浏览器）和服务器之间的请求和响应的格式与规则，从而实现数据的交换。

HTTP 的主要用途是：

1. **资源获取**：客户端可以通过 HTTP 向服务器发送请求，获取 HTML、CSS、JavaScript、图片、视频等各种资源，以便呈现和运行网页或其他应用。
2. **数据提交**：客户端可以通过 HTTP 将数据提交给服务器，例如表单提交、文件上传等。
3. **API 交互**：客户端和服务器可以通过 HTTP 进行 API 交互，以便在前后端之间传递数据。常见的数据格式包括 JSON 和 XML。

HTTP 协议的特点：

1. **无状态**：HTTP 是无状态的，意味着服务器不会存储与客户端之间交互的信息。为了实现有状态的会话，可以使用 Cookie 和 Session 等技术。
2. **简单快速**：HTTP 协议简单，易于实现。客户端和服务器之间的请求和响应报文格式统一，便于解析和处理。
3. **可扩展**：HTTP 允许自定义请求头和响应头，可以根据需要扩展协议的功能。
4. **明文传输**：HTTP 协议本身不提供数据加密功能，所有数据以明文形式传输。为了提高数据安全性，可以使用 HTTPS（HTTP Secure，基于 SSL/TLS 的 HTTP）进行加密传输。

HTTP 协议包括一系列请求方法（如 GET、POST、PUT、DELETE 等），用于指定请求的类型和目的。此外，HTTP 协议还定义了一系列状态码，用于表示请求的结果和相关信息。


### Q.  HTTP的400、401、403的区别
HTTP 状态码 400、401 和 403 分别表示客户端请求错误、未经授权和禁止访问，它们之间有一些区别：

- 400 Bad Request（请求错误）： 这个状态码表示服务器无法理解客户端发送的请求，通常是因为请求中包含了语法错误、无效的参数或格式不正确等问题。当服务器收到 400 错误时，通常会返回一个错误页面或者错误信息，提示客户端检查请求内容并修正错误。

- 401 Unauthorized（未经授权）： 这个状态码表示客户端发送的请求需要进行身份认证，但是没有提供有效的身份凭证（如登录凭证、令牌等）。通常情况下，服务器会返回一个包含身份认证要求的响应，并在响应头中包含一个 WWW-Authenticate 头字段，提示客户端提供有效的身份凭证。

- 403 Forbidden（禁止访问）： 这个状态码表示客户端没有权限访问请求的资源，即使提供了有效的身份凭证。服务器收到请求后，会认识到请求者身份合法，但是服务器拒绝该请求访问所请求的资源。通常情况下，服务器会返回一个错误页面或者错误信息，说明客户端无权访问该资源。

总的来说，400 表示客户端请求错误，401 表示未经授权需要身份认证，403 表示服务器拒绝访问，即使客户端提供了有效的身份凭证。这些状态码可以帮助客户端识别和处理不同类型的请求问题。


### Q. HTTP常见状态码

### Q. TCP中三次握手和四次挥手的含义

在 TCP（传输控制协议）中，三次握手和四次挥手是用来建立和终止连接的重要过程。下面分别解释它们的含义：

**三次握手（Three-Way Handshake）**：

三次握手是建立 TCP 连接的过程，确保数据传输的可靠性和连接的双向通信。这个过程包含三个步骤：

1. 客户端向服务器发送一个 SYN（同步）报文，表示客户端希望建立连接。报文中包含一个随机生成的序列号（Sequence Number）。
2. 服务器收到 SYN 报文后，回复一个 SYN+ACK（同步确认）报文，其中 ACK 的值为客户端序列号加一。同时，服务器也会发送一个自己的随机序列号。
3. 客户端收到 SYN+ACK 报文后，发送一个 ACK（确认）报文给服务器，其中 ACK 的值为服务器序列号加一。

完成这三个步骤后，客户端和服务器之间的 TCP 连接就建立好了，可以进行双向通信。

**四次挥手（Four-Way Handshake）**：

四次挥手是终止 TCP 连接的过程。当数据传输完成后，客户端和服务器需要通过四次挥手来关闭连接。这个过程包含四个步骤：

1. 客户端发送一个 FIN（完成）报文给服务器，表示客户端已完成数据发送。
2. 服务器收到 FIN 报文后，回复一个 ACK（确认）报文给客户端，表示已收到客户端的关闭请求。此时，客户端到服务器的连接被关闭，但服务器到客户端的连接仍然存在。
3. 当服务器完成数据发送后，也会发送一个 FIN 报文给客户端，表示服务器准备关闭连接。
4. 客户端收到服务器的 FIN 报文后，回复一个 ACK 报文给服务器，表示已收到服务器的关闭请求。经过一段时间（通常为 2MSL，即最长报文段寿命的两倍）后，客户端关闭与服务器的连接。

完成这四个步骤后，客户端和服务器之间的 TCP 连接就被完全关闭了。



### Q.  TCP提供了什么服务？

传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议。它为应用程序之间提供可靠的数据传输服务。TCP在Internet协议族中被广泛应用，与网络层协议IP（Internet Protocol）共同组成TCP/IP协议簇。

TCP提供的服务包括：

1. 面向连接：TCP在数据传输前建立一个连接。连接的建立、维护和终止都由TCP管理。这种面向连接的方式使得TCP适用于需要可靠通信的应用。
2. 可靠传输：TCP通过使用确认机制、重传机制和错误校验来确保数据的可靠传输。如果数据包丢失或损坏，TCP会自动重发数据包，从而保证数据的完整性和正确性。
3. 流量控制：TCP使用滑动窗口机制来实现流量控制，确保接收方的缓冲区不会被发送方的数据溢出。这样，发送方和接收方可以根据自身处理能力和网络状况动态调整传输速率，提高传输效率。
4. 拥塞控制：为了防止网络拥塞，TCP使用拥塞控制算法来调整发送数据的速率。当网络出现拥塞时，TCP会减少发送速率，避免网络拥塞进一步恶化。当网络恢复正常时，TCP会逐渐提高发送速率。
5. 数据排序：TCP会为每个数据包分配一个序号，接收方可以根据序号重新组合数据包，从而确保数据按正确顺序传输。
6. 复用与分用：TCP允许多个应用程序在同一台主机上通过不同的端口共享网络资源。这意味着多个应用程序可以在同一时间使用TCP进行数据传输，而不会互相干扰。



### Q.  SSL/TLS是如何握手的？

SSL（安全套接层）和TLS（传输层安全）协议用于在互联网上建立安全的、加密的通信连接。尽管TLS是SSL的后续版本，但在实际用语中，它们经常互换使用。TLS握手过程可以分为以下几个步骤：

1. 客户端发起连接：客户端（例如，浏览器）向服务器发起一个安全连接请求。这个请求包括客户端支持的TLS版本、支持的加密套件（加密算法和密钥交换方法的组合）以及一个随机数（ClientHello 随机数）。
2. 服务器响应：服务器从客户端提供的加密套件列表中选择一个加密套件，并向客户端返回服务器的证书（包含公钥和服务器身份信息）、选择的TLS版本和加密套件，以及一个随机数（ServerHello 随机数）。此外，如果需要客户端身份验证，服务器还会请求客户端的证书。
3. 证书验证：客户端验证服务器证书的有效性。证书应由受信任的证书颁发机构（CA）签名。这一步的目的是确保与客户端通信的服务器是可信的，防止中间人攻击。
4. 密钥交换：客户端使用服务器证书中的公钥加密一个新的随机数（称为 Pre-Master Secret），并将其发送给服务器。服务器使用其私钥解密 Pre-Master Secret。然后，客户端和服务器分别使用 ClientHello 随机数、ServerHello 随机数和 Pre-Master Secret，通过一个伪随机函数生成主密钥（Master Secret）。这个主密钥将用于之后的对称加密和解密操作。
5. 客户端和服务器协商参数：客户端和服务器根据主密钥生成一组加密参数（例如，对称密钥、初始化向量、消息验证码等），这些参数将用于保护后续的数据传输。
6. 客户端和服务器验证握手过程：客户端发送一个加密的 Finished 消息，服务器解密并验证消息的完整性。服务器也发送一个加密的 Finished 消息，客户端解密并验证。这一步的目的是确保双方已正确完成密钥交换和参数协商。
7. 加密数据传输：完成握手过程后，客户端和服务器使用协商的加密参数进行安全的数据传输。此时，所有传输的数据都是加密的，以确保其机密性和完整性。

TLS握手过程旨在在客户端和服务器之间建立一个安全、加密的通信通道，以保护数据在互联网上的传输。



### Q.  数字证书里面主要包含什么信息？

数字证书，通常用于 SSL/TLS 通信和其他加密场景，是一个电子文档，用于证明公钥的所有权和身份。数字证书通常由认证机构 (CA) 签署。以下是数字证书中主要的包含的信息：

1. **主体信息（Subject）**：
    - **公钥（Public Key）**：该证书对应的公钥。
    - **主体的名称（Subject Name）**：通常为网站的域名或组织的名称。
    - **组织名称（Organization Name）**：证书持有者的组织或公司名称（例如，"OpenAI Inc."）。
    - **组织单位（Organizational Unit, OU）**：组织内的特定部门或单位。
    - **地理位置信息**：如国家（Country）、州/省（State/Province）、城市（Locality）等。

2. **颁发者信息（Issuer）**：
    - **颁发者名称（Issuer Name）**：签发该证书的证书认证机构 (CA) 的名称。
    - 和主体类似，可能还包括组织名称、组织单位、国家等信息。

3. **有效期（Validity Period）**：
    - **开始日期（Not Before）**：证书的有效开始日期。
    - **结束日期（Not After）**：证书的过期日期。

4. **序列号（Serial Number）**：颁发者给证书分配的唯一编号，用于识别。

5. **签名算法（Signature Algorithm）**：用于签署此证书的算法（如 RSA、ECDSA 或其他）。

6. **证书签名（Signature）**：CA 使用其私钥生成的证书的数字签名。这使得其他人可以使用 CA 的公钥来验证证书的真实性和完整性。

7. **扩展和约束（Extensions and Constraints）**：这些是可选的，但在许多证书中都有。它们为证书提供了额外的属性和规则。例如：
    - **Key Usage**：描述公钥可以用于什么（例如，数据加密、数字签名等）。
    - **Extended Key Usage**：进一步详细说明公钥的使用，如服务器身份验证、客户端身份验证等。
    - **Subject Alternative Name (SAN)**：除主体名称外，其他有效的名称（通常用于多域名或通配符证书）。
    - **Certificate Policies**：关于证书如何使用和 CA 如何管理证书的策略。

8. **版本（Version）**：证书的版本号。目前，最常见的版本是 v3。

当客户端（例如，web 浏览器）接收到数字证书时，它会使用相关 CA 的公钥来验证证书的签名，从而验证证书的真实性。此过程有助于确保在网络上进行的通信是安全和加密的。


### Q.  Websocket与Ajax的区别？

WebSocket 和 Ajax 是两种不同的 Web 技术，它们在实现客户端与服务器之间通信时有一些区别。以下是它们之间的主要区别：

1. **连接方式**：
   - WebSocket：WebSocket 是一种全双工通信协议，建立连接后，客户端和服务器之间可以同时进行数据发送和接收。WebSocket 连接在建立后会保持连接状态，直至显式断开连接。
   - Ajax：Ajax（Asynchronous JavaScript and XML）是一种基于 HTTP 协议的异步请求技术。每次 Ajax 请求都需要建立一个新的 HTTP 连接，请求完成后连接会被关闭。因此，Ajax 是一种基于请求-响应模式的半双工通信方式。
2. **实时性**：
   - WebSocket：由于 WebSocket 是全双工通信，服务器可以在任何时候主动向客户端发送数据，因此实时性较强，适用于实时通信、在线游戏等场景。
   - Ajax：由于 Ajax 基于请求-响应模式，服务器不能主动向客户端发送数据，客户端需要定期发起请求以获取更新。因此，实时性相对较弱，适用于非实时的数据获取和更新。
3. **开销和性能**：
   - WebSocket：WebSocket 在建立连接后会保持连接状态，因此减少了频繁建立和断开连接的开销。同时，WebSocket 使用自己的二进制分帧格式进行数据传输，帧头较小，数据传输效率较高。
   - Ajax：每次 Ajax 请求都需要建立新的 HTTP 连接，这会导致一定的性能开销。另外，HTTP 协议的请求和响应头部较大，相对降低了数据传输效率。

总结：WebSocket 适用于实时性要求较高、需要双向通信的场景，而 Ajax 更适用于传统的 Web 应用，用于获取和更新数据。根据实际应用需求，可以选择合适的技术进行通信。



### Q.  HTTP1.0、HTTP1.1、HTTP2.0之间有什么区别

1. **HTTP/1.0**:
   - **无连接**：每个 HTTP 请求打开一个新的连接，请求结束后立即关闭连接。
   - **无状态**：每个请求都是独立的，服务器不保存之前的请求信息。
   - **缓存**：使用简单的 `Pragma: no-cache` 来避免缓存。

2. **HTTP/1.1**:
   - **长连接**：引入了持久连接，这意味着多个 HTTP 请求和响应可以在一个连接中连续发送，避免了为每个请求都建立新连接的开销。这是通过 `Connection: keep-alive` 头来实现的。
   - **管线化**：请求可以同时被发送，但是服务器必须按照它们接收到的顺序来逐一响应。
   - **缓存控制**：更加详细和精确的缓存头，如 `Cache-Control`，提供了更好的缓存管理。
   - **主机头的要求**：允许多个域名解析到同一 IP 地址，从而使虚拟主机成为可能。
   - **错误通知**：增加了更多的状态码和更丰富的错误信息。

3. **HTTP/2**:
   - **二进制协议**：不再是像 HTTP/1.x 那样的文本协议，而是一个二进制协议。这使得协议的解析、网络传输更高效。
   - **多路复用**：允许多个请求和响应在一个连接上同时并行交换，解决了 HTTP/1.1 中的“线头阻塞”问题。
   - **优先级和权重**：可以为请求设置优先级和权重，使得重要的请求得到更快的响应。
   - **服务器推送**：服务器可以对客户端“推送”资源，即使客户端尚未请求。
   - **首部压缩**：使用 HPACK 压缩，减少了请求和响应的大小。
   - **更强的流控制**：为每一个流提供了流控制机制。



### Q.  HTTP/2相比HTTP/1.1新增了什么

HTTP/2 是 HTTP/1.1 的升级版本，旨在解决 HTTP/1.1 中的一些性能问题，提高网络传输的效率。HTTP/2 相比于 HTTP/1.1 主要有以下新增特性：

1. **二进制分帧**：HTTP/2 将数据以二进制格式进行传输，请求和响应被分解为更小的帧，每个帧有自己的类型和标识符。这使得数据传输更加高效，易于解析。
2. **多路复用**：HTTP/2 允许在同一个 TCP 连接上同时发送和接收多个请求和响应，避免了 HTTP/1.1 中的队头阻塞问题。这样可以提高页面加载速度，减少网络延迟。
3. **头部压缩**：HTTP/2 使用 HPACK 压缩算法对请求和响应头部进行压缩，减小了传输数据的大小，从而降低了传输延迟。
4. **服务器推送**：HTTP/2 服务器可以主动将一些尚未被客户端请求的资源推送给客户端，以便客户端在需要时立即使用，提高了资源加载速度。



### Q.  HTTP/3相比HTTP/2解决了哪些问题？

HTTP/3 是互联网工程任务组（IETF）制定的新一代 HTTP（超文本传输协议）标准，它基于 QUIC 协议（快速 UDP 互联网连接），旨在解决 HTTP/2 存在的一些问题，提高网络性能和安全性。相较于 HTTP/2，HTTP/3 主要解决了以下问题：

1. 首部阻塞（Head-of-line blocking）：在 HTTP/2 中，多个请求和响应通过同一个 TCP 连接进行多路复用。由于 TCP 是面向连接的、可靠的传输协议，要求数据按顺序到达，当其中一个数据包丢失或延迟时，整个连接的其他数据包必须等待，直到丢失的数据包被重新传输并到达。这种现象被称为首部阻塞。HTTP/3 采用基于 UDP 的 QUIC 协议，它允许单独处理每个数据流，从而消除了首部阻塞问题。
2. 连接建立延迟：HTTP/2 在建立 TCP 连接之后，还需要通过 TLS 握手建立安全连接。这意味着需要多次往返才能完成连接建立。而 HTTP/3 使用 QUIC 协议，它将传输层（TCP）和安全层（TLS）整合在一起，从而减少了连接建立所需的往返次数。对于已经与服务器建立过连接的客户端，QUIC 甚至可以实现 0-RTT（零往返时间）连接建立，大幅降低了延迟。
3. 更好的网络路径迁移：当客户端或服务器的 IP 地址发生变化时（如移动设备在 Wi-Fi 和移动网络之间切换），TCP 连接可能中断，需要重新建立。HTTP/3 的 QUIC 协议提供了内置的连接迁移特性，允许在 IP 地址变化时保持连接状态，减少中断和延迟。
4. 拥塞控制和恢复：由于 HTTP/3 使用 QUIC 协议，它可以在单独的数据流上实现更细粒度的拥塞控制。这意味着当一个数据流受到网络拥塞影响时，其他数据流可以继续正常传输，不受影响。同时，QUIC 采用了更先进的丢包恢复机制，使得数据传输更加高效和可靠。

尽管 HTTP/3 有很多优势，但它目前仍在逐步推广和普及。浏览器和服务器需要支持 QUIC 协议，以便充分利用 HTTP/3 带来的改进。


### Q.  GET和POST请求的区别是什么？

GET和POST是HTTP协议中最常见的两种请求方法，它们之间的主要区别包括：

1. **请求参数的传递方式不同**：
   - GET请求的参数被附加到URL之后，以键值对的形式出现，各参数之间以&符号分割，如`http://example.com/page?param1=value1&param2=value2`。
   - POST请求的参数存储在请求体（Request Body）中。

2. **数据大小的限制不同**：
   - GET由于受URL长度限制，所以能传递的参数量相对有限。
   - POST请求由于参数在请求体中，理论上数据量没有限制，但实际上大小会受到WEB服务器的限制。

3. **安全性不同**：
   - GET请求的参数直接被包含在URL中，数据暴露给了用户，安全性较低，因此不适合传递敏感信息。
   - POST请求的参数在请求体中，用户无法在地址栏看到，安全性相对较高。

4. **可缓存**：
   - GET请求的结果通常可以被浏览器或代理服务器缓存。
   - POST请求的结果则通常不被缓存。

5. **幂等性和副作用**：
   - GET是幂等的，也就是说，无论调用一次还是多次，产生的效果是相同的。
   - POST不是幂等的，每次请求都可能导致不同的结果。

6. **请求的用途**：
   - GET通常用于请求服务器数据，例如网页浏览、图片加载等。
   - POST通常用于提交数据给服务器，例如表单提交、文件上传等。

虽然GET和POST是最常见的HTTP请求方法，但HTTP协议还定义了其他一些请求方法，如PUT、DELETE、PATCH、HEAD等，每种方法都有其特定的用途和语义。


### Q.  TCP与UDP有什么区别？

TCP（传输控制协议）和UDP（用户数据报协议）是互联网协议套件的两个主要协议，它们用于不同类型的网络服务，并具有各自的特点和用途。以下是它们的主要区别：

1. **连接类型**：
   - TCP是一种面向连接的协议，这意味着在数据交换之前，必须首先建立连接。一旦建立了连接，就会保持开放状态，直到所有数据传输完毕。TCP使用的是可靠的通信通道，确保数据的完整性和顺序。
   - UDP是一种无连接的协议，这意味着它不需要在发送数据之前建立连接。因此，UDP的通信通道是不可靠的，无法保证数据的完整性和顺序。

2. **速度和可靠性**：
   - TCP提供了一种可靠的数据传输方法，通过校验和、序列号、确认应答、重传机制和拥塞控制等机制，确保数据在网络中的正确无误的传输。但这些特性使得TCP相比UDP来说速度较慢。
   - UDP不提供数据可靠性，它只是简单地发送数据，不进行错误检查或数据恢复。这意味着如果网络出现问题，数据可能会丢失。但由于缺少了这些额外的特性，UDP的速度通常比TCP快。

3. **使用场景**：
   - TCP常用于需要高可靠性的应用，如Web浏览器、电子邮件服务、文件传输等。
   - UDP常用于对实时性要求较高、可接受一些数据丢失的应用，如流媒体、在线游戏和VoIP（网络电话）。

4. **报头长度**：
   - TCP的报头长度更长，最小为20字节，因为它包含了许多控制信息（如序列号和确认号）。
   - UDP的报头长度较短，只有8字节，因为它只提供基本的功能。

5. **流量控制和拥塞控制**：
   - TCP有内置的流量控制和拥塞控制机制，这使得TCP可以在网络繁忙时降低数据发送速度，以防止数据丢失。
   - UDP没有这些控制机制，所以在网络繁忙时可能会导致大量数据丢失。

总的来说，TCP和UDP都有它们各自的优势和使用场景。选择使用哪一个协议取决于特定的应用需求，如需要可靠性还是速度，以及对数据丢失的容忍度。

### Q.  HTTP中，get、post、put、delete有什么区别？

HTTP中的GET、POST、PUT、DELETE是四种常见的HTTP方法（也称为“动词”），它们各自代表了不同的操作，通常用于RESTful Web服务中。以下是这四种方法的基本区别：

1. **GET**：
   - 用途：获取资源信息。
   - 安全性：GET是安全的，这意味着它只是获取信息并不改变资源状态。
   - 幂等性：GET是幂等的，这意味着多次执行同一GET请求，结果都是一样的。
   - 数据传输：参数包含在URL中，因此数据量有限，并且可能被记录在日志中。
   - 缓存：GET请求的响应是可以被缓存的。
   - 示例：访问一个网页或获取某个项目的详细信息。

2. **POST**：
   - 用途：提交数据并创建新资源。
   - 安全性：POST不是安全的，因为它可能改变资源的状态。
   - 幂等性：POST不是幂等的，因为重复发送同一个POST请求可能会有不同的效果（例如，重复创建相同的资源）。
   - 数据传输：参数不在URL中，而是在请求体中。因此，可以发送大量的数据。
   - 示例：填写并提交一个表单。

3. **PUT**：
   - 用途：更新现有资源或创建新资源。
   - 安全性：PUT不是安全的。
   - 幂等性：PUT是幂等的，重复执行同一PUT请求应该总是产生相同的结果。
   - 数据传输：数据在请求体中。
   - 示例：更新一个项目的详细信息。

4. **DELETE**：
   - 用途：删除资源。
   - 安全性：DELETE不是安全的。
   - 幂等性：DELETE是幂等的，因为无论删除多少次，资源都已经被删除。
   - 数据传输：通常不带请求体，资源标识通常在URL中。
   - 示例：删除一个项目。

---

### Q. 常见的请求方式 GET POST PUT DELETE , 各种方式传参是在URL上还是body上

🧭 快速总览表

| 方法       | 语义   | 参数传递位置                                   | 是否常用于读取/提交 | 特点说明             |
| -------- | ---- | ---------------------------------------- | ---------- | ---------------- |
| `GET`    | 获取资源 | ✅ URL 查询参数（query string）<br>❌ Body 一般不会用 | ✅ 读取       | 可缓存、可收藏、用于查询数据   |
| `POST`   | 新增资源 | ✅ Body<br>✅ 可带 URL 查询参数                  | ✅ 提交       | 不可缓存、适合提交表单/复杂数据 |
| `PUT`    | 更新资源 | ✅ Body<br>✅ 可带 URL 查询参数（如 ID）            | ✅ 提交       | 幂等（多次操作效果一致）     |
| `DELETE` | 删除资源 | ✅ 可带 URL 查询参数<br>✅ Body（不推荐）             | ✅ 提交       | 幂等，但可能不同服务风格略异   |


✅ 小结：参数放哪儿？

| 方法     | 参数放 URL？ | 参数放 Body？ | 最佳实践            |
| ------ | -------- | --------- | --------------- |
| GET    | ✅ 是      | ❌ 否（不推荐）  | 查询参数写 URL       |
| POST   | ✅ 可选     | ✅ 是（推荐）   | 主体数据放 Body      |
| PUT    | ✅ 可选     | ✅ 是（推荐）   | 用于更新，Body 是更新数据 |
| DELETE | ✅ 是      | ❌ 有争议     | 通常用 URL 带资源 ID  |


---

### Q. Content-Type有哪些

Content-Type是标识请求体或响应数是什么格式的HTTP头部字段。

📦 一、最常见的 Content-Type 类型

| 类型                                  | 值         | 说明                                          |
| ----------------------------------- | --------- | ------------------------------------------- |
| `application/json`                  | JSON 格式数据 | 前后端通信常用格式，适合结构化数据                           |
| `application/x-www-form-urlencoded` | 表单键值对     | 默认的 HTML 表单提交格式，如：`key1=value1&key2=value2` |
| `multipart/form-data`               | 多段数据（含文件） | 用于上传文件，表单里含 `file` 时自动使用                    |
| `text/plain`                        | 纯文本数据     | 不编码、不解释，仅原始字符串                              |
| `application/xml`                   | XML 格式数据  | 旧系统、部分接口使用                                  |
| `text/html`                         | HTML 格式数据 | 一般用于响应体，某些特殊接口也接受                           |


📘 其他常见类型（多见于特定场景）

| Content-Type               | 用途                         |
| -------------------------- | -------------------------- |
| `application/javascript`   | JS 资源（响应）                  |
| `application/octet-stream` | 任意二进制流（如下载文件）              |
| `text/csv`                 | 表格导出数据                     |
| `application/pdf`          | 返回 PDF 文档                  |
| `application/zip`          | 返回压缩包                      |
| `image/png`、`image/jpeg`   | 处理图像请求                     |
| `audio/mpeg`、`video/mp4`   | 媒体流播放等                     |
| `application/graphql`      | GraphQL 请求                 |
| `application/x-ndjson`     | 新行分隔的 JSON（streaming JSON） |
