
## 浏览器

### Q.  说一说从输入URL到页面呈现发生了什么

从输入 URL 到页面呈现，经历了以下几个主要步骤：

1. **地址解析**：浏览器首先解析输入的 URL，提取协议、域名、端口和路径等信息。

2. **DNS 查询**：浏览器通过 DNS 查询将域名解析为 IP 地址。如果浏览器或操作系统缓存中已有相应的 DNS 记录，将直接使用缓存的结果；否则，浏览器将发送请求到 DNS 服务器进行查询。

3. **建立 TCP 连接**：浏览器与目标服务器建立 TCP 连接，进行三次握手。这一步确保了数据传输的可靠性。

4. **发送 HTTP 请求**：浏览器构建 HTTP 请求报文，包含请求头（如 User-Agent、Accept 等）和请求体（如 POST 提交的表单数据），然后通过建立的 TCP 连接将请求报文发送给服务器。

5. **服务器响应**：服务器收到请求后，处理请求并生成响应报文，包含响应头（如 Content-Type、Content-Length 等）和响应体（如请求的 HTML 文件）。服务器通过 TCP 连接将响应报文发送回浏览器。

6. **浏览器接收响应**：浏览器接收并解析响应报文，提取状态码、响应头和响应体等信息。

7. **解析 HTML**：浏览器开始解析 HTML 文档，构建 DOM 树。遇到外部资源（如 CSS、JavaScript、图片等），浏览器会发起额外的请求获取这些资源。

8. **解析 CSS**：浏览器解析 CSS 文件，构建 CSSOM 树。CSSOM 树和 DOM 树会被合并为渲染树。

9. **执行 JavaScript**：浏览器解析并执行 JavaScript 代码。注意，JavaScript 的执行可能会修改 DOM 树和 CSSOM 树，从而影响渲染树的构建。

10. **构建渲染树**：浏览器将 DOM 树和 CSSOM 树合并为渲染树，包含每个可见元素的布局信息。

11. **布局**：浏览器根据渲染树计算每个元素的准确位置和大小，确定页面的布局。

12. **绘制**：浏览器遍历渲染树，将每个元素绘制到屏幕上。

13. **合成**：在某些情况下，浏览器会将页面分成多个层进行绘制。最后，这些层会按照特定顺序合成为最终的页面视图。

14. **页面呈现**：浏览器将渲染好的页面呈现给用户。


总之，从输入 URL 到页面呈现，浏览器经历了一系列复杂的过程。理解这些过程有助于我们优化前端性能，提高用户体验。

---

### Q.  html解析过程

HTML（超文本标记语言）是用于构建和呈现网页内容的标准标记语言。浏览器解析HTML的过程包括以下几个步骤：

1. 获取HTML文档：浏览器首先向服务器发送请求，获取HTML文档。服务器响应请求并返回HTML文件，通常是一个以`.html`或`.htm`为扩展名的文件。
2. 词法分析：浏览器开始对HTML文档进行词法分析，将其分解成各种符号（tokens），例如标签、属性和文本内容。词法分析的结果是一系列token，这些token有助于构建DOM树。
3. 构建DOM树：浏览器将词法分析得到的tokens用于构建DOM（文档对象模型）树。DOM树是一种表示HTML文档结构的树形数据结构，其中每个节点代表页面上的一个元素、属性或文本内容。
4. 解析CSS：浏览器会解析与HTML文档关联的CSS样式表，包括内联样式、内部样式和外部样式。解析CSS样式后，浏览器会生成CSSOM（CSS对象模型）树，这是一种表示CSS样式的树形结构。
5. 构建渲染树：浏览器将DOM树和CSSOM树合并，生成渲染树。渲染树包含了页面上可见的所有元素及其样式信息。隐藏元素（如`display: none;`）不会包含在渲染树中。
6. 布局（Layout）：根据渲染树，浏览器计算每个元素在页面上的准确位置和大小。这个过程也被称为重排（reflow）。
7. 绘制（Painting）：布局完成后，浏览器开始将元素绘制到屏幕上。这个过程包括绘制文本、颜色、图片、边框等视觉效果。
8. 合成（Compositing）：在某些情况下，浏览器会将页面分成多个层进行绘制。最后，这些层会按照特定顺序合成为最终的页面视图。

在整个解析过程中，浏览器可能还需要处理JavaScript代码。JavaScript可以通过修改DOM树、CSSOM树和触发事件等方式影响页面的呈现。

---

### Q.  讲讲浏览器的进程和线程

浏览器的进程和线程是浏览器实现其功能的基础。它们之间的关系和任务分工对于理解浏览器的运行原理和性能优化至关重要。简单来说，进程是操作系统资源分配的最小单位，而线程是操作系统调度（CPU 利用率）的最小单位。

**进程**：

进程是一个运行中的程序实例，它包含程序所需的所有资源。一个进程拥有独立的内存空间、全局变量、打开的文件和设备等。浏览器中的进程主要有以下几类：

1. **浏览器主进程**：负责协调浏览器的各个模块，包括用户界面、地址栏、书签栏等。它还负责管理浏览器的各个标签页进程和插件进程。
2. **渲染进程**：负责将网页内容渲染到屏幕上。每个标签页通常对应一个渲染进程（在某些情况下，标签页可能会共享一个渲染进程）。渲染进程包括 HTML、CSS 和 JavaScript 的解析、布局、渲染以及执行等任务。
3. **插件进程**：负责运行和管理浏览器插件（如 Flash）。
4. **网络进程**：负责处理网络请求，包括资源的下载、上传和缓存。

**线程**：

线程是进程中的一个执行单元，它共享进程的资源，如内存空间和文件句柄。一个进程可以有多个线程，这些线程可以并发执行任务。在浏览器中，有以下几种主要的线程：

1. **主线程**：渲染进程的主要执行线程，负责解析和执行 JavaScript 代码、处理 DOM 事件、执行 CSS 动画等任务。主线程是单线程的，这意味着 JavaScript 的执行和页面渲染任务需要排队执行。
2. **Web Workers**：一种可以在后台运行 JavaScript 代码的线程，它与主线程独立，不会阻塞主线程。Web Workers 可以用于执行耗时的计算任务，避免影响页面渲染。
3. **Service Workers**：用于实现离线缓存、消息推送、后台同步等功能的独立线程。Service Workers 与 Web Workers 类似，但具有更多的 API 和能力。
4. **渲染线程**：负责将解析好的 HTML、CSS 和图像资源绘制到屏幕上。渲染线程与主线程是分离的，这意味着页面的渲染和 JavaScript 的执行是并行进行的。
5. **合成线程**：负责处理页面的合成和分层。当浏览器检测到可以使用 GPU 加速的动画时，合成线程会将这些动画分离出来并在 GPU 上独立运行。这可以避免主线程的阻塞，提高页面的性能。
6. **网络线程**：负责处理 HTTP 请求和响应，以及与服务器之间的通信。网络线程与主线程独立，以避免网络请求导致的阻塞。
7. **定时器线程**：负责处理 JavaScript 中的定时器任务（如 `setTimeout` 和 `setInterval`）。这些任务会在定时器线程上排队执行，然后在指定的时间后将回调函数推送到主线程的任务队列中。
8. **解析线程**：负责解析 HTML 和 CSS。解析线程会将解析后的 DOM 树和 CSSOM 树合并为渲染树，并传递给渲染线程进行绘制。在某些情况下，解析线程和主线程可能会合并为一个线程，这取决于浏览器的具体实现。
9. **文件线程**：负责处理与文件系统的交互，如读取和写入操作。这些操作在文件线程上执行，避免阻塞主线程。

以上就是浏览器中的一些主要进程和线程。需要注意的是，不同浏览器的实现可能会有所不同，但它们的基本原理和任务分工是类似的。理解这些进程和线程之间的关系有助于我们更好地理解浏览器的运行原理，从而优化前端性能。

---

### Q.  谈谈你对跨域资源共享CORS的理解

跨域资源共享（Cross-Origin Resource Sharing，简称 CORS）是一种安全机制，允许一个网页的资源（例如 AJAX 请求、字体、图片等）从不同的源（域名、协议或端口）访问。由于同源策略（Same-origin policy）的限制，不同源的网页通常无法互相访问资源。CORS 通过在 HTTP 头中加入特定的字段，使得浏览器和服务器之间可以协商，从而允许跨域请求。

CORS 主要通过以下几种方式实现跨域访问：

1. **简单请求**：简单请求是指满足一定条件的跨域请求，包括使用以下 HTTP 方法之一：GET、HEAD、POST，并且 HTTP 头信息不超出以下字段：Accept、Accept-Language、Content-Language、Content-Type（限于 application/x-www-form-urlencoded、multipart/form-data、text/plain）。对于简单请求，浏览器会在请求中添加 `Origin` 头，指示请求来自哪个源。服务器接收到请求后，如果允许跨域访问，会在响应头中添加 `Access-Control-Allow-Origin` 字段。
2. **预检请求**：预检请求（Preflight request）是一种 CORS 机制，用于处理不满足简单请求条件的跨域请求。预检请求使用 OPTIONS 方法发送，浏览器会在请求头中包含 `Origin`、`Access-Control-Request-Method` 和 `Access-Control-Request-Headers` 字段。服务器收到预检请求后，如果允许跨域访问，会在响应头中添加 `Access-Control-Allow-Origin`、`Access-Control-Allow-Methods`、`Access-Control-Allow-Headers` 等字段。预检请求成功后，浏览器才会发送实际的跨域请求。
3. **携带身份凭证**：CORS 还支持在跨域请求中携带身份凭证（如 Cookie），通过设置 `withCredentials` 属性为 `true`。在这种情况下，服务器需要在响应头中添加 `Access-Control-Allow-Credentials: true` 字段，以允许携带身份凭证的请求。同时，`Access-Control-Allow-Origin` 字段不能为通配符（`*`），必须指定具体的源。

总的来说，CORS 通过在 HTTP 头中添加特定的字段，使得浏览器和服务器之间可以协商允许跨域访问。这种机制确保了 Web 应用程序的安全性，同时允许跨域资源共享。在实际开发中，服务器端需要正确配置 CORS 相关的响应头，以支持跨域请求。

### Q.  谈一谈跨域，同源策略，以及跨域解决方案

**同源策略**： 同源策略是一种安全机制，用于限制文档或脚本从不同来源的数据进行交互。当两个资源具有相同的协议（如 http 或 https）、域名和端口时，它们被认为是同源的。同源策略限制了从一个源加载的网页脚本与来自另一个源的资源进行交互的能力，以防止恶意行为，如跨站脚本攻击（XSS）或数据窃取。

**跨域**： 跨域是指当一个资源试图访问来自不同源的另一个资源时，由于同源策略的限制而无法进行的情况。例如，一个从 `http://example-a.com` 加载的网页试图通过 AJAX 请求 `http://example-b.com` 上的数据，这就是一个跨域请求。

**跨域解决方案**： 有多种方法可以绕过同源策略的限制，实现跨域请求。以下是一些常见的跨域解决方案：

1. **CORS（跨域资源共享）**： CORS 是一种官方推荐的跨域解决方案。它允许服务器通过设置响应头（如 `Access-Control-Allow-Origin`）来放宽对跨域请求的限制。浏览器将根据这些响应头决定是否允许跨域请求。
2. **JSONP（JSON with Padding）**： JSONP 利用了 `<script>` 标签的 src 属性不受同源策略限制的特性。它通过动态创建一个 `<script>` 标签，并将回调函数作为参数传递给服务器。服务器将请求数据包装在回调函数中，并将其作为响应返回。客户端脚本收到响应后，会立即执行回调函数以获取数据。
3. **使用代理服务器**： 可以通过代理服务器将跨域请求转发到目标服务器。这样，客户端与代理服务器之间的请求就是同源的，而代理服务器与目标服务器之间的请求则由代理服务器完成。常见的代理服务器实现方式有 Nginx 反向代理、Node.js 中间件代理等。
4. **使用 iframe 和 postMessage**： 可以使用 iframe 加载跨域页面，然后通过 `window.postMessage` 方法在不同源的窗口之间传递消息。这种方法需要跨域页面的配合，以便在接收到消息时执行相应操作。
5. **使用 WebSockets**： WebSockets 可以实现跨域通信，因为它们不受同源策略限制。通过建立一个 WebSocket 连接，客户端和服务器可以进行双向通信，实现跨域数据交换。
6. **使用 CORS 代理**： 如果目标服务器没有实现 CORS，而你又不想在自己的服务器上设置反向代理，可以使用第三方 CORS 代理服务。这些服务在请求目标服务器时为你添加 CORS 响应头，从而使浏览器允许跨域请求。但请注意，这可能会带来安全风险，因此不建议在生产环境中使用。
7. **使用 document.domain**： 当两个具有相同根域名但子域名不同的页面需要进行跨域通信时，可以将它们的 `document.domain` 设置为相同的值。这样，它们将被视为同源，可以进行通信。但此方法仅适用于具有相同根域名的情况。
8. **使用 window.name**： 可以利用 `window.name` 在同源和跨域的窗口之间传递数据。`window.name` 属性在窗口跳转时会保留其值，因此可以将数据存储在 `window.name` 中，然后通过跳转到同源页面来读取数据。但这种方法受到一些限制，只能传递字符串数据，且安全性和可靠性相对较低。

每种跨域解决方案都有其优缺点，需要根据实际场景和需求选择合适的方法。现代 Web 开发中，CORS 是最常用且推荐的解决方案。但在某些特殊场景或者兼容旧版浏览器时，可能需要考虑其他方案。在实现跨域时，始终要关注安全性和数据保护，确保不会引入安全漏洞。




### Q.  为什么JS执行时会阻塞页面加载

JavaScript 执行阻塞页面加载的原因是浏览器在解析和渲染 HTML 文档时遵循自上而下的顺序。当浏览器遇到一个 `<script>` 标签时（尤其是外部 JavaScript 文件），它会立即下载并执行这个脚本。由于 JavaScript 可能会修改 DOM 结构或操作 CSSOM（如添加、删除元素或更改样式），浏览器必须确保在执行 JavaScript 之前，先解析完 JavaScript 之前的 HTML 和 CSS。这样可以**防止页面出现不一致的渲染效果**。

因此，当浏览器遇到一个 JavaScript 脚本时，它会：

1. 阻塞 HTML 解析。
2. 如果有外部 JavaScript 文件，发送请求并等待下载完成。
3. 执行 JavaScript 代码。
4. 继续解析剩余的 HTML 文档。

JavaScript 执行阻塞页面加载可能会导致性能问题和较差的用户体验。为了解决这个问题，可以采用以下策略：

1. **将脚本放在文档底部**：将 `<script>` 标签放在文档的底部，紧邻 `</body>` 标签。这样可以确保在执行 JavaScript 之前，先解析完 HTML 和 CSS，从而减少阻塞时间。
2. **使用 `defer` 属性**：给 `<script>` 标签添加 `defer` 属性，可以告诉浏览器在下载脚本的同时继续解析 HTML。脚本将在文档解析完成后顺序执行。例如：`<script src="example.js" defer></script>`。
3. **使用 `async` 属性**：给 `<script>` 标签添加 `async` 属性，可以使脚本异步下载和执行。这意味着脚本会在下载完成后立即执行，而不用等待其他脚本。请注意，这可能会导致脚本执行顺序发生变化，因此只适用于那些不依赖其他脚本的独立脚本。例如：`<script src="example.js" async></script>`。

通过采用这些策略，可以减少 JavaScript 对页面加载的阻塞性，提高页面性能和用户体验。

### Q.  说一说你对Cookie localStorage sessionStorage的理解

Cookie、localStorage 和 sessionStorage 都是在客户端存储数据的技术，但它们之间有一些关键的区别：

1. **Cookie**：
   - Cookie 最初是为了在客户端保存用户会话信息而设计的，它们可以在客户端和服务器之间进行传递。
   - Cookie 的大小限制为 4KB 左右，因此不适合存储大量数据。
   - Cookie 有一个有效期，可以设置为特定的时间长度。过期后，Cookie 会被自动删除。
   - Cookie 可能面临安全风险，如跨站请求伪造（CSRF）攻击。因此，在使用 Cookie 时需要采取一定的安全措施。
   - 因为每次 HTTP 请求都会携带 Cookie，所以频繁操作 Cookie 可能会影响性能。
2. **localStorage**：
   - localStorage 是 HTML5 引入的一种客户端存储技术，允许在用户的浏览器中存储较大量的数据（通常为 5-10MB，根据浏览器实现有所不同）。
   - localStorage 中存储的数据没有有效期，会一直保留，除非用户手动清除或者使用代码进行删除。
   - localStorage 只在客户端进行操作，不会与服务器进行通信。
   - localStorage 的数据存储在同一个域名下，不同域名之间的 localStorage 数据是隔离的。
3. **sessionStorage**：
   - sessionStorage 与 localStorage 非常相似，它们都是 HTML5 引入的客户端存储技术，具有相同的存储容量限制。
   - 与 localStorage 不同的是，sessionStorage 的数据仅在当前浏览器标签或窗口的生命周期内有效。当用户关闭标签或窗口时，sessionStorage 中的数据会被自动清除。
   - sessionStorage 同样只在客户端进行操作，不会与服务器进行通信。
   - sessionStorage 的数据同样存储在同一个域名下，不同域名之间的 sessionStorage 数据是隔离的。

总之，Cookie、localStorage 和 sessionStorage 都是客户端存储技术，但它们之间在数据有效期、存储容量和与服务器通信等方面有所不同。根据具体需求和场景，开发者可以选择合适的技术进行数据存储。

### Q.  怎么实现sessionstorage在同源窗口共享


1. 页面通过监听storage事件指定的key比如`getSessionStorage`, 将页面的sessionStorage通过localStorage中转写入`sessionStorageData`
2. 新窗口监听storage中的`sessionStorageData`, 即拿到了sessionStorage
3. 触发getSessionStorage

```js
// 所有已打开的页面监听 localStorage 事件
window.addEventListener('storage', (event) => {
  if (event.key === 'getSessionStorage') {
    // 返回当前 tab 的 sessionStorage 数据（可以过滤需要的 key）
    localStorage.setItem('sessionStorageData', JSON.stringify(sessionStorage));
    // 一次性传输后删除，避免污染
    localStorage.removeItem('sessionStorageData');
  }
});

window.addEventListener('storage', (event) => {
  if (event.key === 'sessionStorageData') {
    const data = JSON.parse(event.newValue);
    for (const key in data) {
      sessionStorage.setItem(key, data[key]);
    }
  }
});

localStorage.setItem('getSessionStorage', Date.now()); 
// 触发 storage事件key为getSessionStorage, 其它窗口将sessionStorage写入localStorage中， 又触发storage事件的sessionStorageData, 当前窗口/标签即拿到共享的sessionStorage数据。

```
如果已经有多个标签页，当前操作会由多个标签页返回它各自的sessionStorage数据，可以由主标签页来响应， 比如在主标签页中的sessionStorage添加一项特殊的key


### Q.  讲讲浏览器缓存

浏览器缓存是一种性能优化技术，通过将已请求的资源（如 HTML、CSS、JavaScript、图片等）存储在本地，以减少网络请求和数据传输。当用户再次访问相同的资源时，浏览器可以直接从缓存中获取，从而加快页面加载速度、降低服务器压力和减少网络流量消耗。

浏览器缓存主要分为以下几种类型：

1. **强缓存**： 强缓存是指浏览器在缓存期间内不会再向服务器发送任何请求，而是直接从本地缓存中获取资源。强缓存由以下两个 HTTP 响应头控制：
   - `Expires`：指定资源的过期时间。例如：`Expires: Wed, 21 Oct 2023 07:28:00 GMT`。但由于服务器时间和客户端时间可能存在差异，所以这个响应头不太准确。
   - `Cache-Control`：使用更现代且准确的方式控制缓存。例如：`Cache-Control: max-age=3600`，表示资源的缓存有效期为 3600 秒。其他可用的指令还包括 `no-cache`、`no-store`、`must-revalidate` 等。
2. **协商缓存**： 当强缓存失效后，浏览器会向服务器发送请求，以验证资源是否有更新。协商缓存通过以下 HTTP 响应头和请求头控制：
   - `Last-Modified` 和 `If-Modified-Since`：服务器返回资源时，通过 `Last-Modified` 响应头指定资源最后修改时间。浏览器下次请求时会通过 `If-Modified-Since` 请求头发送这个时间。服务器会比较这个时间和资源的实际修改时间，如果没有变化，则返回 `304 Not Modified` 状态码，浏览器将使用本地缓存；否则返回更新后的资源和新的 `Last-Modified` 时间。
   - `ETag` 和 `If-None-Match`：`ETag` 是服务器为资源生成的唯一标识（通常是哈希值）。浏览器下次请求时会通过 `If-None-Match` 请求头发送这个标识。服务器会比较这个标识和资源的当前 `ETag`，如果相同，则返回 `304 Not Modified` 状态码；否则返回更新后的资源和新的 `ETag`。
3. **其他缓存技术**： 除了上述浏览器缓存机制外，还有一些其他缓存技术，如 Service Workers、Memory Cache、IndexedDB 等。它们可以根据具体需求和场景进行灵活地缓存策略配置。

### Q.  前端如何进行seo优化

前端在进行搜索引擎优化（SEO）时，可以从以下几个方面进行优化：

1. **合理的标题、描述和关键词**： 确保每个页面都有独特且描述准确的`<title>`标签和`<meta name="description">`标签。这有助于搜索引擎理解页面内容，同时也为用户在搜索结果中显示更具吸引力的信息。
2. **语义化的 HTML 结构**： 使用语义化的 HTML 标签，如`<header>`、`<footer>`、`<nav>`、`<section>`、`<article>`等，以帮助搜索引擎更好地理解页面结构和内容。
3. **良好的页面结构**： 确保页面具有清晰的层次结构和导航，这有助于搜索引擎爬虫更容易地抓取和索引页面内容。
4. **优化 URL 结构**： 使用简洁且描述性的 URL，避免过长或包含不必要的参数。这有助于搜索引擎理解页面内容，并提高用户体验。
5. **使用 header 标签**： 使用`<h1>`至`<h6>`等 header 标签来组织页面内容，确保每个页面只有一个`<h1>`标签。这有助于搜索引擎理解页面的主题和重要性。
6. **图片优化**： 为所有图片添加`alt`属性，以便搜索引擎了解图片内容。同时，优化图片大小和格式，以提高页面加载速度。
7. **内部链接和锚文本**： 合理地使用内部链接和有意义的锚文本，以帮助搜索引擎更好地理解站点结构和内容之间的关联。
8. **响应式设计**： 确保网站适应不同设备和屏幕尺寸，提供良好的用户体验。搜索引擎倾向于对移动友好的网站给予更高的排名。
9. **网站速度优化**： 提高网站加载速度，减少页面渲染时间。这包括压缩资源、合并文件、优化图片、使用浏览器缓存等。搜索引擎会考虑网站速度作为排名的因素之一。
10. **遵循 W3C 标准**： 确保代码符合 W3C 标准，减少 HTML、CSS 和 JavaScript 的错误。这有助于搜索引擎更容易地抓取和解析页面内容。
11. **生成 XML Sitemap**： 为网站创建一个 XML Sitemap，并提交给搜索引擎。这有助于搜索引擎更有效地抓取和索引网站内容。
12. **使用结构化数据**： 使用结构化数据（如 Schema.org、JSON-LD、Microdata 等）来标注页面内容，有助于搜索引擎更准确地理解页面信息，并可能在搜索结果中显示为富文本摘要，提高点击率。
13. **使用 robots.txt 控制爬虫访问**： 合理设置 robots.txt 文件，指定搜索引擎爬虫可以访问和抓取的页面，避免爬虫抓取不相关或低质量的页面。
14. **优化站内搜索**： 提供高效、准确的站内搜索功能，有助于提高用户体验和用户停留时间，间接影响搜索排名。
15. **社交媒体整合**： 将网站内容与社交媒体平台整合，提高内容的曝光度和分享率，增加外部链接，有助于提高搜索排名。
16. **网站安全**： 使用 HTTPS 加密，保护用户数据和隐私。搜索引擎会将安全性作为排名因素之一。

总之，前端在进行 SEO 优化时，要关注页面结构、内容、用户体验和技术实现等多个方面。通过提高页面质量、提升用户体验和遵循搜索引擎的最佳实践，有助于提高网站在搜索结果中的排名和可见度。

### Q.  requestAnimationFrame与requestIdleCallback区别

`requestAnimationFrame`和`requestIdleCallback`都是浏览器提供的用于优化JavaScript任务调度的API。它们之间的主要区别在于它们的使用场景和触发时机。

1. **requestAnimationFrame**：

`requestAnimationFrame`主要用于优化浏览器的动画渲染。它允许你在浏览器即将进行下一次重绘之前安排一个回调函数执行。这意味着，回调函数将在最佳的时间点执行，从而提高动画的性能和流畅度。

`requestAnimationFrame`的优点包括：

- 与浏览器的刷新率同步，避免动画卡顿或丢帧现象。
- 当页面不可见或最小化时，浏览器会暂停执行`requestAnimationFrame`回调，从而减少CPU和GPU的使用，节省资源。

典型的`requestAnimationFrame`用法如下：

```js
function animate() {
  // 执行动画操作
  ...
  // 在下一次重绘之前请求执行动画
  requestAnimationFrame(animate);
}

requestAnimationFrame(animate);
```

1. **requestIdleCallback**：

`requestIdleCallback`用于优化非关键性任务的执行，例如代码分析、日志报告、数据存储等。当浏览器空闲时，`requestIdleCallback`会触发回调函数执行，从而避免阻塞关键任务，如渲染、动画和用户交互。

`requestIdleCallback`的优点包括：

- 利用浏览器的空闲时间执行低优先级任务，避免干扰关键任务。
- 可以设置超时时间，确保在指定时间内完成任务。

典型的`requestIdleCallback`用法如下：

```js
function performNonCriticalTask(deadline) {
  while (deadline.timeRemaining() > 0) {
    // 执行非关键任务
    ...
  }

  // 如果还有未完成的任务，继续请求空闲回调
  requestIdleCallback(performNonCriticalTask);
}

requestIdleCallback(performNonCriticalTask);
```

总之，`requestAnimationFrame`和`requestIdleCallback`分别用于优化动画渲染和非关键性任务的执行。`requestAnimationFrame`在每次浏览器重绘之前执行回调，以实现高性能的动画效果；`requestIdleCallback`则在浏览器空闲时执行回调，避免影响关键任务。

---

### Q.  SSR的实现原理？

服务器端渲染（Server Side Rendering，简称 SSR）是一种 web 应用的渲染方式，其实现原理是在服务器端将页面内容渲染为 HTML 字符串，然后将这些字符串发送到客户端，客户端接收到 HTML 后直接显示，无需等待 JavaScript 的解析、执行和渲染。

SSR 的核心实现原理可以概括为以下几个步骤：

1. **请求处理**：客户端发起请求时，请求首先到达服务器。
2. **服务器渲染**：服务器接收到请求后，根据路由和数据，将对应的页面内容渲染为 HTML 字符串。这一步通常涉及到模板引擎或服务器端 JavaScript 框架的使用，例如 React 的 `ReactDOMServer.renderToString()` 和 Vue 的 `vue-server-renderer`。
3. **数据注入**：在渲染过程中，服务器还需要获取所需的数据，将其注入到 HTML 中。这可以通过内联脚本、JSON 格式或其他方式实现。数据注入的目的是在客户端 JavaScript 代码运行时能够获取到服务器端已经准备好的数据，避免重复请求。
4. **生成完整 HTML**：将渲染好的 HTML 字符串插入到 HTML 模板中，形成一个完整的 HTML 页面。这个页面包含了已经渲染好的内容以及必要的 JavaScript、CSS 等资源引用。
5. **发送响应**：服务器将完整的 HTML 页面作为响应发送给客户端。客户端接收到响应后，直接将 HTML 页面展示给用户。
6. **客户端接管**：在客户端，浏览器会解析和执行 JavaScript 代码，接管页面的交互和操作。这一步通常被称为 "hydration" 或 "激活"，因为客户端 JavaScript 代码需要 "激活" 服务器端渲染的静态 HTML，使其具有动态功能。

通过 SSR，用户可以更快地看到页面的内容，因为无需等待客户端的 JavaScript 代码下载、解析、执行和渲染。此外，由于搜索引擎爬虫能够更好地解析服务器端渲染的 HTML，因此 SSR 对 SEO 也有一定的优势。然而，SSR 也会增加服务器的负担，因为服务器需要负责渲染页面。在实际应用中，可以根据项目需求和性能要求，选择合适的渲染方式。



### Q.  讲讲你对PWA的理解

PWA（Progressive Web App，渐进式 web 应用）是一种将现代 web 技术与传统移动应用功能结合的应用开发模式。PWA 旨在通过提供原生应用的类似体验，改进 web 应用的可用性、性能和用户体验。PWA 的核心技术包括 Service Workers、Web App Manifest 和离线缓存等。

PWA 的主要特点如下：

1. **可靠性**：通过 Service Workers 和离线缓存技术，PWA 可以在无网络或网络不稳定的环境下运行。用户在访问 PWA 时，即使断网，也能看到离线内容或自定义的离线提示页面。
2. **快速**：PWA 通过预缓存关键资源和优化加载策略，提高了应用的加载速度和运行性能。在访问 PWA 时，用户可以更快地看到页面内容，并感受到流畅的交互体验。
3. **可安装**：通过 Web App Manifest，PWA 可以被添加到用户的设备主屏幕，并以独立窗口运行，类似于原生应用。用户可以直接从主屏幕启动 PWA，而无需通过浏览器。
4. **跨平台**：PWA 基于 web 技术，因此可以在不同的操作系统和设备上运行，包括桌面和移动设备。这意味着，开发者只需维护一套代码，就能为多个平台提供类似的应用体验。
5. **更新简便**：PWA 无需通过应用商店发布和更新。当用户访问 PWA 时，应用会自动检查并应用更新。这样，用户总是能获取到最新的应用版本，而开发者也能更轻松地发布和管理更新。
6. **安全**：PWA 需要通过 HTTPS 运行，确保数据传输的安全性。同时，由于 Service Workers 可以拦截和处理请求，PWA 还可以实现更丰富的安全策略和功能，如请求过滤、内容安全策略（CSP）等。
7. **可搜索**：PWA 作为 web 应用，可以被搜索引擎抓取和索引。这意味着，PWA 可以获得更好的搜索引擎优化（SEO），提高应用的可见度和用户获取途径。

总之，PWA 是一种充分利用现代 web 技术，为用户提供原生应用般体验的 web 应用开发模式。通过 PWA，开发者可以实现更可靠、快速、可安装和跨平台的应用，提升用户体验和满意度。


### Q.  谈谈浏览器的离线缓存与本地缓存的区别

浏览器的离线缓存和本地缓存都是用于在用户设备上存储数据以提高网页性能的技术，但它们的实现方式和使用场景略有不同。下面是它们之间的一些主要区别：

1. 目的：

离线缓存：主要用于在用户离线时仍然可以访问网页。它可以在没有网络连接的情况下提供基本的功能，如查看已缓存页面的内容。

本地缓存：主要用于减少网络延迟，提高加载速度。通过在用户设备上缓存常用资源，如图片、脚本、样式等，可以在用户再次访问网站时直接从缓存中读取，降低服务器负担和提高用户体验。

2. 存储类型：

离线缓存：使用HTML5的Application Cache（AppCache）和Service Worker技术实现。这些技术允许开发者为用户设备创建一个离线版本的网页，包括HTML、CSS、JavaScript等资源。

本地缓存：使用浏览器提供的缓存策略和存储机制实现，如HTTP缓存、Cookie、Web Storage（包括localStorage和sessionStorage）和IndexedDB等。

3. 生命周期：

离线缓存：由开发者通过AppCache或Service Worker配置文件控制，包括缓存资源的更新和过期策略。

本地缓存：由浏览器或服务器通过HTTP头部字段（如Cache-Control、Expires等）控制，或通过脚本（如localStorage和IndexedDB）设置的存储时间限制。

4. 适用场景：

离线缓存：适用于需要在无网络环境下访问的网页，例如离线阅读应用、PWA（Progressive Web Apps）等。

本地缓存：适用于任何需要提高网站性能和加载速度的场景，减少不必要的网络请求。

总之，离线缓存和本地缓存都是为了优化网页性能，它们各自针对不同的使用场景。离线缓存主要是为了在没有网络连接时继续访问网页，而本地缓存则是为了提高网页加载速度和降低服务器负担。

### Q.  谈谈你对Shadow DOM的理解

Shadow DOM 是 Web Components 规范的一个重要组成部分，它提供了一种将 HTML、CSS 和 JavaScript 封装在独立、隔离的 DOM 结构中的方法，从而实现组件的样式和行为的封装。Shadow DOM 解决了全局样式污染的问题，使得开发者可以创建具有独立样式和逻辑的可重用组件。

Shadow DOM 的关键特点如下：

1. **封装**：Shadow DOM 允许将一组 DOM 元素和相关样式封装在一个独立的、隔离的 DOM 树中。这样，组件的样式不会影响到主文档，同样主文档的样式也不会影响到组件。通过这种封装，组件可以在不同的应用中重用，而无需担心样式污染和冲突。
2. **隔离**：Shadow DOM 的树结构是隔离的，意味着组件内的 DOM 元素和 JavaScript 逻辑与主文档是分开的。这有助于保护组件内的数据和方法，避免被外部访问和修改。
3. **附件阴影树**：通过 `attachShadow` 方法，可以在一个普通的 DOM 元素上创建一个 Shadow DOM。这个普通元素被称为 "Shadow Host"，而创建的 Shadow DOM 被称为 "Shadow Tree"。Shadow Tree 与主文档的 DOM 树是并列的，互不干扰。
4. **插槽（Slot）**：Shadow DOM 支持使用 `<slot>` 元素来分发（或投影）主文档中的内容。这使得组件可以定义可自定义的内容区域，让使用者在引入组件时提供所需的内容。
5. **样式隔离**：组件内的 CSS 样式只对 Shadow Tree 中的元素生效，不会影响到主文档。同时，主文档的 CSS 样式（除了 CSS 变量）也不会影响到组件。这样，组件的样式能够完全独立，避免了全局样式污染。

总之，Shadow DOM 提供了一种在 Web 开发中实现组件封装和样式隔离的机制。通过使用 Shadow DOM，开发者可以创建具有独立样式和行为的可重用组件，简化开发过程，提高组件的可维护性。


### Q.  当前的前端渲染方式有哪些，谈谈你对它们的理解，并说说它们的优缺点是什么？

当前主要的前端渲染方式有三种：服务器端渲染（SSR）、客户端渲染（CSR）和预渲染（Prerendering）。下面分别阐述这三种渲染方式的特点及优缺点：

1. **服务器端渲染（SSR）**：

   服务器端渲染指的是在服务器上将网页的 HTML、CSS 和 JavaScript 渲染成完整的 HTML 页面，然后将渲染后的页面发送给客户端。客户端接收到页面后直接展示，无需执行额外的 JavaScript。

   - 优点：
     1. 有利于 SEO，因为搜索引擎可以直接爬取完整的 HTML 页面。
     2. 首屏加载速度较快，因为用户无需等待 JavaScript 执行完毕就能看到页面内容。
   - 缺点：
     1. 服务器端压力较大，因为每次请求都需要服务器进行页面渲染。
     2. 用户交互复杂度受限，因为每次交互都可能需要重新渲染页面。

2. **客户端渲染（CSR）**：

   客户端渲染指的是将 HTML、CSS 和 JavaScript 发送给客户端，然后在客户端执行 JavaScript 来生成页面内容。这种方式在现代前端框架（如 React、Vue 和 Angular）中非常常见。

   - 优点：
     1. 服务器压力较小，因为页面渲染工作由客户端完成。
     2. 用户交互体验较好，因为客户端可以实现动态的、无需刷新页面的交互。
   - 缺点：
     1. 首屏加载速度较慢，因为客户端需要等待 JavaScript 执行完毕才能看到页面内容。
     2. 不利于 SEO，因为搜索引擎在爬取页面时可能无法执行 JavaScript。

3. **预渲染（Prerendering）**：

   预渲染是在构建过程中生成静态 HTML 文件，然后将这些静态文件部署到服务器。当用户请求页面时，服务器直接返回对应的静态 HTML 文件。这种方法适用于内容不经常变动的网站。

   - 优点：
     1. 首屏加载速度较快，因为用户无需等待 JavaScript 执行完毕就能看到页面内容。
     2. 有利于 SEO，因为搜索引擎可以直接爬取静态 HTML 页面。
     3. 服务器压力较小，因为页面在构建过程中已经渲染完成。
   - 缺点：
     1. 构建过程可能较慢，尤其是对于大型网站。
     2. 如果网站内容经常变动，需要频繁地重新构建和部署页面。

总结：

每种渲染方式都有其优缺点，具体选择哪种方式要根据实际项目需求进行权衡。以下是一些建议：

- 如果 SEO 对项目至关重要，而且项目内容相对稳定，则可以考虑使用预渲染或服务器端渲染。
- 如果项目需要提供丰富的用户交互体验，可以考虑使用客户端渲染，这样能够充分利用现代前端框架的优势。
- 如果项目的内容动态性较强，可以考虑使用服务器端渲染或客户端渲染。但对于客户端渲染，可能需要考虑使用服务端渲染的同构应用或者采用一些服务器端渲染辅助的技术（如 prerender.io）来提高 SEO 效果。
- 对于首屏加载速度有较高要求的项目，可以考虑使用服务器端渲染或预渲染。

实际项目中，可以根据需求灵活地将不同渲染方式结合使用，以达到最佳的性能和用户体验。例如，可以在服务器端渲染首屏内容以提高首屏加载速度，然后在客户端渲染后续的页面内容以提供更好的交互体验。


---

### Q.  谈谈你对Web Workers的理解

Web Workers 在浏览器中提供了一个单独的、并行的执行环境，可以运行长时间运行的脚本而不会阻塞 UI 线程。然而，这个执行环境与主 JavaScript 执行环境相比有一些限制。以下是主要的一些限制：

1. 无法访问 DOM：Web Workers 运行在隔离的线程中，不能直接访问网页的 DOM。任何与 UI 相关的操作都需要通过主线程完成。

2. 无法访问全局对象：Web Workers 不能访问许多全局对象，如 `window` 对象，因为这些对象与 UI 相关或者包含与 UI 相关的功能。

3. 无法访问某些 Web API：像 navigator.geolocation 或者 window.localStorage 这样的 Web API 无法在 Web Workers 中使用。

4. 无法加载其他脚本：Web Workers 无法使用 `<script>` 标签加载其他脚本。但是，可以使用 `importScripts()` 函数来导入其他脚本。

5. 数据传递限制：Web Workers 通过消息传递与主线程通信。这意味着所有的数据在传送时都需要被序列化和反序列化，这可能会对性能产生影响。

6. 运行环境的限制：Web Workers 运行在不同的全局上下文中，即 `DedicatedWorkerGlobalScope`，而不是主线程的 `window`。因此，一些预期在 `window` 上下文中使用的代码在 Web Worker 中可能无法正常工作。

总的来说，Web Workers 是设计用于执行计算密集型或者长时间运行的任务，而非操作 UI 或者处理与 UI 相关的逻辑。对于需要与 UI 交互的操作，仍然需要在主线程中完成。



### Q.  谈谈你对V8垃圾回收的理解？

V8引擎主要采用了两种算法来处理垃圾回收：分代收集（Generational Collection）和增量标记（Incremental Marking）。

1. 分代收集：V8将内存分为两个代：新生代（Young Generation）和老生代（Old Generation）。新生代中的对象存活时间较短，而老生代中的对象存活时间较长。新生代使用Scavenge算法进行垃圾回收，通常采用Cheney算法，将内存分为两个半区（From Space和To Space），每次垃圾回收时，会将存活的对象复制到To Space中，并清空From Space。当一个对象在新生代中经历了多次垃圾回收仍然存活时，会将其移动到老生代。
2. 增量标记：老生代采用标记-清除（Mark-Sweep）算法进行垃圾回收。这种算法首先会标记所有可达的对象，然后清除所有未被标记的对象。为了避免在标记过程中产生长时间的停顿（Stop-The-World），V8采用了增量标记策略。这种策略将标记过程分为多个阶段，在每个阶段之间，JavaScript程序可以继续执行。这样可以降低垃圾回收对程序性能的影响。

V8垃圾回收是对JavaScript垃圾回收策略的具体实现。它采用分代收集和增量标记两种算法，有效降低了垃圾回收对程序性能的影响。



### Q.  如何优化和减少垃圾回收的影响，从而提高应用性能？

以下是一些建议和技巧来帮助优化和减少垃圾回收的影响：

1. **避免全局变量**：全局变量不会被垃圾回收，除非它们被设置为 `null`。只有在确实需要时才应该使用它们。
2. **使用对象池**：对于频繁创建和销毁的对象（如在游戏或高性能应用中的实体），使用对象池可以重用对象而不是每次都创建新的对象。这可以避免频繁的垃圾回收。
3. **小心闭包**：闭包可能会导致意外的引用，从而阻止对象被垃圾回收。确保你只在需要时使用闭包，并在不再需要它们时断开引用。
4. **手动释放大对象**：对于大的数据结构或数组，如果你知道它们不再需要，可以手动将它们设置为 `null`，从而提前提示垃圾回收器。
5. **避免循环引用**：确保对象之间没有循环引用，因为这可能导致它们无法被垃圾回收。
6. **使用弱引用**：在合适的场景下，使用 `WeakMap` 或 `WeakSet` 可以让你存储对对象的引用，而不会阻止这些对象被垃圾回收。
7. **优化事件监听器**：确保及时删除不再需要的事件监听器。未删除的事件监听器可能会导致内存泄漏。
8. **减少内存分配**：减少动态创建对象、数组和闭包的频率可以帮助减少需要回收的垃圾量。
9. **使用浏览器开发者工具**：浏览器提供的开发者工具（如 Chrome DevTools）可以帮助你监测和诊断内存使用情况和潜在的泄漏。
10. **考虑使用 WebAssembly**：对于需要高性能和低延迟的应用，使用 WebAssembly 可能会帮助减少 JavaScript 的垃圾回收的影响，因为 WebAssembly 有自己的内存管理模型。

---

### Q. 浏览器同源的请求并发数限制机制及期数量

浏览器的同源请求并发数限制是指：同一时间内，浏览器对同一“源”发起的 HTTP 请求数量是有限制的。这是为了防止恶意脚本对服务器施加过大负载。

同源是指：协议 + 域名 + 端口 三者相同。

🎯 浏览器同源并发限制是什么？

不同浏览器对“同一源”下的并发请求数是有限制的，一般在：

| 浏览器       | 每个域名的并发数限制              |
| --------- | ----------------------- |
| Chrome    | 6（HTTP/1.1）/ 无限（HTTP/2） |
| Firefox   | 6（默认）                   |
| Safari    | 6                       |
| Edge/IE11 | 6                       |
| 移动浏览器     | 通常是 4～6                 |

--- 